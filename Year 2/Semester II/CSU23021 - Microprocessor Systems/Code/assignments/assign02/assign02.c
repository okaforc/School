#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/clocks.h"
#include "hardware/watchdog.h"
#include "assign02.pio.h"

#include "Array.h"

#define IS_RGBW true        // Will use RGBW format
#define NUM_PIXELS 1        // There is 1 WS2812 device in the chain
#define WS2812_PIN 28       // The GPIO pin that the WS2812 connected to

char* randomAsciiLetter;
char* randomMorseString;
int lives = 3;              // declared the main result 
int wins = 0;
int levelSel = 0;
int stageReached = 1; // determining the stage the player has reached, beginning at stage 1
int seededRandom = 0;
int rounds = 0; // how many rounds played per level

char* morse_letters[] = {
        ".- ",     // A
        "-... ",   // B
        "-.-. ",   // C
        "-.. ",    // D
        ". ",      // E
        "..-. ",   // F
        "--. ",    // G
        ".... ",   // H
        ".. ",     // I
        ".--- ",   // J
        "-.- ",    // K
        ".-.. ",   // L
        "-- ",     // M
        "-. ",     // N
        "--- ",    // O
        ".--. ",   // P
        "--.- ",   // Q
        ".-. ",    // R
        "... ",    // S
        "- ",      // T
        "..- ",    // U
        "...- ",   // V
        ".-- ",    // W
        "-..- ",   // X
        "-.-- ",   // Y
        "--.. ",   // Z
        ".---- ",  // 1
        "..--- ",  // 2
        "...-- ",  // 3
        "....- ",  // 4
        "..... ",  // 5
        "-.... ",  // 6
        "--... ",  // 7
        "---.. ",  // 8
        "----. ",  // 9
        "----- "   // 0
};

char* letters[] = {
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "0"
};

// Must declare the main assembly entry point before use.
void main_asm();
struct Array* delays;

static inline void put_pixel(uint32_t pixel_grb);
static inline uint32_t urgb_u32(uint8_t r, uint8_t g, uint8_t b);

// Get the value of a GPIO pin – see SDK for detail on gpio_get()
int asm_gpio_get(uint pin) {
    return gpio_get(pin);
}

// Set the value of a GPIO pin – see SDK for detail on gpio_put()
void asm_gpio_put(uint pin, bool value) {
    gpio_put(pin, value);
}

// Enable raising and falling-edge interrupt – see SDK for detail on gpio_set_irq_enabled()
void asm_gpio_set_irq(uint pin) {
    gpio_set_irq_enabled(pin, GPIO_IRQ_EDGE_FALL, true);
    gpio_set_irq_enabled(pin, GPIO_IRQ_EDGE_RISE, true);
}

/**
 * @brief Wrapper function used to call the underlying PIO
 *        function that pushes the 32-bit RGB colour value
 *        out to the LED serially using the PIO0 block. The
 *        function does not return until all of the data has
 *        been written out.
 *
 * @param pixel_grb The 32-bit colour value generated by urgb_u32()
 */
static inline void put_pixel(uint32_t pixel_grb) {
    pio_sm_put_blocking(pio0, 0, pixel_grb << 8u);
}


/**
 * @brief Function to generate an unsigned 32-bit composit GRB
 *        value by combining the individual 8-bit paramaters for
 *        red, green and blue together in the right order.
 *
 * @param r     The 8-bit intensity value for the red component
 * @param g     The 8-bit intensity value for the green component
 * @param b     The 8-bit intensity value for the blue component
 * @return uint32_t Returns the resulting composit 32-bit RGB value
 */
static inline uint32_t urgb_u32(uint8_t r, uint8_t g, uint8_t b) {
    return  ((uint32_t)(r) << 8) |
        ((uint32_t)(g) << 16) |
        (uint32_t)(b);
}

// Return the current timestamp as an integer
int asm_mark_time() {
    int val = time_us_32();
    return val;
}

// Append a timestamp to the Delays array
void asm_append_delay(int d) {
    appendArray(delays, d);
}

// Pop the most recent value off the Delays array
void asm_pop_delay(int d) {
    popArray(delays);
}

// Enable .S file to use urgb_u32(uint8_t, uint8_t, uint8_t)
uint32_t asm_colour_map(uint8_t r, uint8_t g, uint8_t b) {
    return urgb_u32(r, g, b);
}

// Enable .S file to use put_pixel(uint8_t)
void asm_light_led(uint32_t v) {
    put_pixel(v);
}

// Print every value in a given Array struct
void printDelays() {
    int i;
    for (i = 0; i < delays->size; i++) {
        printf("%f, ", getArrayValue(delays, i) / 1000000.0);
    }
    printf("\n");
}

// Print every value in a given Array struct
void printArray(struct Array* arr) {
    int i;
    for (i = 0; i < arr->size; i++) {
        printf("%d, ", getArrayValue(arr, i));
    }
    printf("\n");
}

// chooses a letter at random and returns it in array of form array[0] = ascii letter, array[1] = morse code string 
char** randomLetterMorse() {
    int randomNumber = rand() % 36;
    char* asciiLetter = letters[randomNumber];
    char* morseString = morse_letters[randomNumber];
    char** array = malloc(sizeof(char*) * 2);
    array[0] = asciiLetter;
    array[1] = morseString;
    return array;
}

// sets the variables for the random letter and then prints it in ascii form
void printRandomLetter(int level) {
    char** randomLetterChosen = malloc(sizeof(char*) * 2);
    randomLetterChosen = randomLetterMorse();
    randomAsciiLetter = randomLetterChosen[0];
    randomMorseString = randomLetterChosen[1];
    if (level == 1) printf("The character to match is %s, the morse code version of %s is %s\n", randomAsciiLetter, randomAsciiLetter, randomMorseString);
    else if (level == 2) printf("The character to match is %s\n", randomAsciiLetter);
    else printf("Not a valid level");
}

// compares the user input with the random letter (both in morse form) and returns true if they are the same 
bool compareUserInputToRand(char* userInput) {
    // 0 results in false. any other number returns true.
    return !strcmp(userInput, randomMorseString);
}

// takes a morse string and finds its ascii character equivalent, if no equivalent is found it returns '?'
static inline char* morseToAscii(char* morseString) {
    char* temp;
    for (int i = 0; i < 36; i++) {
        temp = morse_letters[i];
        if (strcmp(morseString, temp) == 0) {
            return letters[i];
        }
    }
    return "?";
}

// takes the users input (in morse form) and prints whether or not the user correctly input the letter
void printIfUserCorrect(char* userInput) {
    char* userInputAscii = morseToAscii(userInput);
    if (compareUserInputToRand(userInput) == true) printf("Congratulations! You have correctly matched the letter %s in morse code!\n", randomAsciiLetter);
    else printf("Sorry, the character you were trying to match was %s and you input %s, which is equivalent to '%s'\n", randomMorseString, userInput, userInputAscii);
}

// the morse representation of a series of delays, where any delay less then 0.2 seconds is a dot ('.'), and any delay greater or equal to 0.2 is a dash ('-')
char* convertToMorse(struct Array* arr) {
    int i, limit;
    double dotThresh = 0.2;
    limit = arr->size;
    char* str = malloc(sizeof(char*) * (limit + 1));
    for (i = 0; i < limit; i++) {
        if (getArrayValue(arr, i) == 0) {
            str[i] = ' ';
        }
        else {
            double val = getArrayValue(arr, i) / 1000000.0;
            if (val < dotThresh) {
                str[i] = '.';
            }
            else {
                str[i] = '-';
            }
        }
    }
    str[limit] = '\0';
    return str;
}

// Show the main menu, locking certain levels if the player hasn't reached that state yet.
void showMenu(uint stageReached) {
    put_pixel(urgb_u32(0x00, 0x00, 0xe));
    switch (stageReached) {
    case 1:
        printf(
            "Select difficulty level: \n\t1. Single character, easy (.----) \n\t2. Single character, hard (..---) [LOCKED]\n");
        break;
    case 2:
        printf(
            "Select difficulty level: \n\t1. Single character, easy (.----) \n\t2. Single character, hard (..---)\n");
        break;

    default:
        printf("There's a mistake on our end. We're really sorry about that!\n");
        break;
    }
    printf("Or quit by entering Q (--.-)\n");
}

void showWelcome() {
    printf("+-----------------------------------------+\n");
    printf(":        Group 30 Morse Code Game         :\n");
    printf("+-----------------------------------------+\n");
    printf(":                                         :\n");
    printf(":          Welcome to the game!           :\n");
    printf(":                                         :\n");
    printf(":  Try to convert the alphanumeric (A-Z/  :\n");
    printf(":   1-9) character into morse code        :\n");
    printf(":                                         :\n");
    printf("+-----------------------------------------+\n");
    printf("Use GP21 to control input.\n\n");
}


/*
 * Main entry point for the code - simply calls the main assembly function.
 */
int main() {
    stdio_init_all();                       // Initialise all basic IO
    PIO pio = pio0;                         // Initialise the PIO interface with the assign02 code
    uint offset = pio_add_program(pio, &assign02_program);
    assign02_program_init(pio, 0, offset, WS2812_PIN, 800000, IS_RGBW);
    bool valid_level_sel = true;

    if (watchdog_caused_reboot()) {
        printf("\n\n\nYou took too long to respond! Please enter an input at most every 9 seconds. Game reset.\n\n\n");
    }

    showWelcome();

    delays = newArray(0); // create a new empty array
    // loop until the user decides to quit the game
    while (1) {
        wins = 0;
        lives = 3;
        rounds = 0;
        showMenu(stageReached);
        valid_level_sel = true;
        delays = newArray(0);
        watchdog_update();
        main_asm();
        watchdog_update();

        char* res = convertToMorse(delays);

        if (strcmp(morseToAscii(res), "1") == 0)
            levelSel = 1;
        else if (strcmp(morseToAscii(res), "2") == 0) {
            if (stageReached >= 2) {
                levelSel = 2;
            }
            else {
                printf("Complete an earlier stage to play this level!\n");
                valid_level_sel = false;
            }
        }
        else if (strcmp(morseToAscii(res), "Q") == 0) {
            printf("Goodbye!");
            return 0; // exits main. replace with 'break' to exit main while(1) loop
        }
        else {
            valid_level_sel = false;
        }

        if (valid_level_sel) {
            // only start the game with a valid level input
            if (seededRandom < 1) {
                srand(time_us_32());
                seededRandom++;
            }
            put_pixel(urgb_u32(0x00, 0xe, 0x00));
            watchdog_enable(9000, 1); // enable the watchdog timer, rebooting every 9000ms (9s)
            printf("---------------------------------- GAME START ----------------------------------\n");
            // the game will end if lives is zero or the final score has been reached
            while (lives > 0 && wins != 5) {
                delays = newArray(0); // create a new empty array
                printRandomLetter(levelSel);
                watchdog_update(); // signal an input and update the watchdog timer
                main_asm();
                watchdog_update();
                char* res = convertToMorse(delays);

                if (compareUserInputToRand(res)) {
                    printf(":) Correct!\n");
                    wins++;
                    lives++;
                    if (lives > 3)
                        lives = 3;
                }
                else {
                    printf(":( Incorrect!\n");
                    lives--;
                }

                // switch case on LED RGB values, depending on lives left
                switch (lives) {
                case 3:
                    put_pixel(urgb_u32(0x00, 0xe, 0x00));
                    break;
                case 2:
                    put_pixel(urgb_u32(0x08, 0x10, 0x00));
                    break;
                case 1:
                    put_pixel(urgb_u32(0x10, 0x08, 0x00));
                    break;
                case 0:
                    put_pixel(urgb_u32(0xe, 0x00, 0x00));
                    break;

                default:
                    // default to red rgb
                    put_pixel(urgb_u32(0xe, 0x00, 0x00));
                    break;
                }

                // round summary
                char* temp = morseToAscii(res);
                if (strcmp(temp, "?") == 0) {
                    printf("You input %s, which cannot be translated to an ASCII character.\n", res);
                }
                else {
                    printf("You input %s, which can be translated to %s.\n", res, temp);
                }

                // update and inform user of game status
                printf("\n~~~~~~~~You have gotten %d %s correct and have %d %s remaining.~~~~~~~~\n\n",
                    wins,
                    wins == 1 ? "round" : "rounds",
                    lives,
                    lives == 1 ? "life" : "lives"
                );


                // lost all 3 lives
                if (lives == 0) {
                    // if no more lives, game over
                    printf("You lost all 3 lives!\n\n");
                }

                // win 5 times
                if (wins == 5) {
                    printf("You got 5 correct answers!\n\n");
                    // player is now eligible for the next stage (up to 2)
                    if (stageReached == levelSel && stageReached < 2) {
                        printf("\nYou've unlocked stage %d!\n\n", ++stageReached);
                    }
                }

                rounds++;
            }

            printf("---------------------------------- GAME OVER ----------------------------------\n");
            printf("You got %d rounds correct out of %d rounds played, with %d lives left. That leaves you with a win/loss ratio of %d:%d, or %.3f.\n\n", wins, rounds, lives, wins, rounds, (double)wins / (double)rounds);
        }
        else {
            printf("\nNot a valid level selection.\n\n"); // if the level selection is not valid, print out an error message
        }
    }

    return 0;
}
