public class State {
  ArrayList<Area> areas;
  String name;
  int biggestDiff = 0;
  int biggestDiffCases = 0;
  String bdArea = "";
  int maxBetween = 0;

  public State(String name, ArrayList<Area> areas) {
    this.name = name;
    this.areas = areas;
  }

  public State(String name) {
    this.name = name;
    this.areas = new ArrayList<Area>();
  }

  // Add an area to the ArrayList of areas given an Area object
  void addArea(Area a) {
    areas.add(a);
  }

  // Add an area to the ArrayList of areas given a name, HashMap data, and a GeoID
  void addArea(String name, LinkedHashMap<String, Integer> hm, int id) {
    areas.add(new Area(name, hm, id, this));
  }

  // Add an area to the ArrayList of areas given a name, two ArrayLists of data, and a GeoID
  void addArea(String name, ArrayList<String> dates, ArrayList<Integer> cases, int id) {
    areas.add(new Area(name, dates, cases, id, this));
  }

  // Return the ArrayList of areas
  ArrayList<Area> getAreas() {
    return areas;
  }

  // Return the ArrayList of area names
  ArrayList<String> getAreaNames() {
    LinkedList<String> tNames = new LinkedList<String>();
    for (Area a : areas) {
      tNames.add(a.getName());
    }
    ArrayList<String> names = new ArrayList<String>();
    names.addAll(tNames);
    return names;
  }

  // Return an area from the ArrayList of areas given a name
  Area getArea(String name) {
    for (Area a : areas) {
      if (a.getName().equalsIgnoreCase(name)) {
        return a;
      }
    }
    return null;
  }

  // Return an area from the ArrayList of areas given an index
  Area getArea(int index) {
    if (index >= 0 && areas != null) {
      try {
        Area a = areas.get(index);
        if (a != null) {
          return areas.get(index);
        }
      } 
      catch(Exception e) {
      }
    }
    return null;
  }

  // Return the total amount of cases from each area in the state
  public int totalCases() {
    int cases = 0;
    for (Area a : areas) {
      cases += a.getCases();
    }
    return cases;
  }

  // Return the highest amount of cases from each area in the state
  public int maxCases() {
    int maxCase = 0;
    for (Area a : areas) {
      int tCase = a.maxCases();
      if (tCase > maxCase) {
        maxCase = tCase;
      }
    }
    return maxCase;
  }

  // Return the cases at a given date
  public ArrayList<Integer> areaCases(String date) {
    LinkedList<Integer> stateCases = new LinkedList<Integer>();
    for (Area a : areas) {
      for (String d : a.getData().keySet()) {
        if (d.equalsIgnoreCase(date)) {
          stateCases.add(a.getCases(date));
        }
      }
    }
    ArrayList<Integer> actCases = new ArrayList<Integer>();
    actCases.addAll(stateCases);
    return actCases;
  }

  // Return an ArrayList with the amount of cases in each state.
  // A LinkedList is used here to preserve the order of the cases. (I'm not sure if that actually does anything though)
  public ArrayList<Integer> areaCases() {
    LinkedList<Integer> stateCases = new LinkedList<Integer>();
    for (Area a : areas) {
      stateCases.add(a.getCases());
    }
    ArrayList<Integer> actCases = new ArrayList<Integer>();
    actCases.addAll(stateCases);
    return actCases;
  }

  // Return an index of an area given a GeoID
  public int indexOf(int id) {
    for (int i = 0; i < areas.size(); i++) {
      Area a = areas.get(i);
      if (id == a.getGeoID()) {
        return i;
      }
    }
    return -1;
  }

  // Return a LinkedHashMap with the data from each area in the state.
  public LinkedHashMap<String, Integer> totalData() {
    LinkedHashMap<String, Integer> finData = new LinkedHashMap<String, Integer>();
    for (String date : areas.get(0).getData().keySet()) {
      int vad = 0;
      for (Area a : areas) {
        for (String d : a.getData().keySet()) {
          if (d.equalsIgnoreCase(date)) {
            vad += a.getCases(date);
          }
        }
      }
      finData.put(date, vad);
    }
    return finData;
  }

  // Return the highest amount of cases from the totalData method
  public int maxTotalData() {
    return Collections.max(totalData().values());
  }

  // Return the name of the state
  public String getName() {
    return name;
  }

    // Return a LinkedHashMap with the values around the highest difference between two dates.
    // This is compared with the highest difference from each area in the state.
    public LinkedHashMap<String, Integer> stateDiff(ArrayList<Area> arr, int spread) {
        int cBCases = 0;
        Area cBArea = new Area();
        for (Area a : arr) {
            a.areaDiff(a.getData(), spread); // initialises biggestDiff and biggestDiffCases in the current area.
            int bd = a.biggestDiff();
            if (bd > cBCases) {
                biggestDiff = bd;
                biggestDiffCases = a.biggestDiffCases();
                cBCases = bd;
                cBArea = a;
                bdArea = a.getName();
            }
        }
        return cBArea.areaDiff(cBArea.getData(), spread);
    }

  // Returns the actual difference from the stateDiff method.
  public int biggestDiff() {
    return biggestDiff;
  }

  // Returns the max cases from the dates with the highest difference in cases
  public int biggestDiffCases() {
    return biggestDiffCases;
  }

  // Returns the area with the highest difference in cases
  public String biggestDiffArea() {
    return bdArea;
  }

  public ArrayList<String> makeDates(LinkedHashMap<String, Integer> tData) { // 06/04 - Beibhinn - I made this so I could return the arraylist of dates for a dropdown menu in main
    ArrayList<String> sDates = new ArrayList<String>();
    for (String ww : tData.keySet()) {
      sDates.add(ww);
    }
    return sDates;
  }


  public LinkedHashMap<String, Integer> atDates(LinkedHashMap<String, Integer> tData, String d1, String d2) {
    ArrayList<String> sDates = makeDates(tData);
    LinkedHashMap<String, Integer> dbd = new LinkedHashMap<String, Integer>();  // data between dates
    int ind1 = sDates.indexOf(d1);
    int ind2 = sDates.indexOf(d2);
    for (String d : sDates) {
      try {    
        if (sDates.indexOf(d) >= ind1 && sDates.indexOf(d) <= ind2) {
          dbd.put(d, tData.get(d));
          maxBetween = tData.get(d);
        }
      } 
      catch (Exception e) {
        println("Date not in area");
      }
    }
    return dbd;
  }

  public int maxBetween() {
    return maxBetween;
  }

  boolean containsArea(String name) {
    for (Area a : areas) {
      if (a.getName().equalsIgnoreCase(name)) {
        return true;
      }
    }
    return false;
  }
}
