import processing.core.*; 
import processing.data.*; 
import processing.event.*; 
import processing.opengl.*; 

import java.util.AbstractMap.SimpleEntry; 
import java.util.Map.Entry; 
import java.util.*; 

import java.util.HashMap; 
import java.util.ArrayList; 
import java.io.File; 
import java.io.BufferedReader; 
import java.io.PrintWriter; 
import java.io.InputStream; 
import java.io.OutputStream; 
import java.io.IOException; 

public class loadTableData extends PApplet {






public void settings() {
    // size(1024, 500);
    fullScreen();
}
TableData td;
Graph g1;

public void setup() {
    td = new TableData("cases-1k.csv");
    for (String s : td.getInfo("50", "cases")) {
        println(s);
    }
    g1 = new Graph(100, 100, width - width/4, height/2, color(200, 200, 255, 150), 10, "bar", "guideline");
    
}


public void draw() {
    background(0);
    
    // Get data on Cook, Illinois
    g1.setLineDensity(20);
    int st = 10;
    State state = td.world.get(0).getState("Washington");
    Area area = state.getArea("King");
    g1.loadData(area.getData());
    g1.setLimits("set", 0, 100, 0, area.getCase(area.indexOf(Collections.max(area.getData().values()))), 10, 13);
    g1.setLabel("Dates", "Cases", area.getName() + ", " + state.getName());
    g1.displayGraph();
}

public void removeDuplicates(ArrayList arr) {
    // send arraylist to linkedhashset to preserve order and remove duplicated
    Set<Object> tempSet = new LinkedHashSet<Object>(arr);   
    arr.clear();
    arr.addAll(tempSet);
}
public class Area {
    String name;
    int id;
    LinkedHashMap<String, Integer> data = new LinkedHashMap<String, Integer>();

    public Area(String name, ArrayList<String> dates, ArrayList<Integer> cases, int id) {
        this.name = name;
        this.id = id;
        if (name.equalsIgnoreCase("Unknown")) {
            this.id = 0;
        }
        for (int i = 0; i < cases.size(); i++) {
            if (cases.get(i) == null) {
                cases.set(i, 0);
            }
            if (dates.get(i) == null) {
                if (i != cases.size() - 1) {
                    dates.set(i, dates.get(i + 1));
                } else {
                    dates.set(i, dates.get(i - 1));
                }
            }
            data.put(dates.get(i), cases.get(i));
        }
    }

    public Area(String name, LinkedHashMap<String, Integer> values, int id) {
        this.name = name;
        this.data = values;
        this.id = id;
    }

    public Area(String name, String date, Integer cases, int id) {
        this.name = name;
        data.put(date, cases);
        this.id = id;
    }

    public Area(String name, int id) {
        this.name = name;
        this.data = new LinkedHashMap<String, Integer>();
        this.id = id;
    }

    public void addInfo(ArrayList<String> dates, ArrayList<Integer> cases) {
        for (int i = 0; i < cases.size(); i++) {
            data.put(dates.get(i), cases.get(i));
        }
    }

    public void addInfo(LinkedHashMap<String, Integer> values) {
        data = values;
    }

    public void addInfo(String date, Integer cases) {
        data.put(date, cases);
    }

    public int getCases(String date) {
        return data.get(date);
    }

    public int indexOf(int cases) {
        ArrayList<Integer> nCases = new ArrayList<Integer>();
        nCases.addAll(data.values());
        return nCases.indexOf(cases);
    }

    public int getCase(int index) {
        LinkedHashMap<String, Integer> hMap = new LinkedHashMap<String, Integer>();
        hMap = data;
        ArrayList<Integer> l = new ArrayList<Integer>(hMap.values());
        return l.get(index);
    }

    public LinkedHashMap<String, Integer> getData() {
        return data;
    }

    public ArrayList<String> getDates(int cases) {
        ArrayList<String> dac = new ArrayList<String>();
        for (String d : data.keySet()) {
            if (data.get(d) >= cases) {
                dac.add(d);
            }
        }
        return dac;
    }

    public ArrayList<String> datesAtCase(int cases) {
        ArrayList<String> dac = new ArrayList<String>();
        for (String d : data.keySet()) {
            if (data.get(d) >= cases) {
                dac.add(d);
            }
        }
        return dac;
    }

    public String getName() {
        return name;
    }

    public int getGeoID() {
        return id;
    }

    public void setID(int newID) {
        this.id = newID;
    }
}
public class Country {
    ArrayList<State> states;
    String name;
    public Country(String name, ArrayList<State> states) {
        this.name = name;
        this.states = states;
    }

    public Country(String name) {
        this.name = name;
        states = new ArrayList<State>();
    }

    public void addState(State c) {
        states.add(c);
    }

    public void addState(String c) {
        states.add(new State(c));
    }

    public State getState(String name) {
        if (name != null && states != null) {
            for (State s : states) {
                if (name.equalsIgnoreCase(s.getName())) {
                    return s;
                }
            }
        }
        return null;
    }

    public State getState(int index) {
        if (index >= 0 && states != null) {
            try {
                State s = states.get(index);
                if (s != null) {
                    return states.get(index);
                }
            } 
            catch(Exception e) {
            }
        }
        return null;
    }

    public ArrayList<State> getStates() {
        return states;
    }

    public String getName() {
        return name;
    }
}
public class Graph {
    float xPos, yPos, gWidth, gHeight;
    float xMin, xMax, yMin, yMax;
    int textSize, xSteps, ySteps;
    int bg;
    boolean grid = false, guideline = false, blank = false;
    boolean data_gen = false, data_set = false;
    String graphType;
    float lineDensity = 0;
    float barGap = 20;
    LinkedHashMap<String, Integer> data = new LinkedHashMap<String, Integer>();
    Graph (float x, float y, float gWidth, float gHeight, int bg, int textSize, String graphType, String design) {
        xPos = x;
        yPos = y; this.gWidth = gWidth; this.gHeight = gHeight; this.bg = bg; 
        this.graphType = graphType; this.textSize = textSize;
        textSize(textSize);
        switch (design) {
            case "grid":
                grid = true;
            break;
            case "guideline":
                guideline = true;
            break;
            case "blank":
                blank = true;
            break;
            default :
                blank = true;
            break;	
        }
    }

    public void setLimits(String type, float x1, float x2, float y1, float y2, int xSteps, int ySteps) {
        /* 
        * "gen": generic data; integers and/or floats/doubles on both the x and y axis
        * "set": an array of objects; e.g. strings and integers
         */
        xMin = x1;
        xMax = x2;
        yMin = y1;
        yMax = y2;
        this.ySteps = ySteps;
        if (type.equalsIgnoreCase("gen")) {
            this.xSteps = xSteps;
            data_gen = true;
        } else if (type.equalsIgnoreCase("set")) {
            this.xSteps = data.size();
            data_set = true;
        }
    }

    public void loadData(LinkedHashMap<String, Integer> data) {
        this.data = data;
    }

    public void loadData(ArrayList<String> xValues, ArrayList<Integer> yValues) {
        for (int i = 0; i < yValues.size(); i++) {
            data.put(xValues.get(i), yValues.get(i));
        }
    }

    public void setLineDensity(float value) {
        this.lineDensity = value;
    }

    public void setLabel(String xT, String yT, String title) {
        textSize(textSize*1.5f);
        fill(255);
        text(xT, xPos + gWidth/2, yPos + gHeight*1.2f);
        text(title, xPos + gWidth/2, yPos - yPos/3);

        pushMatrix();
        translate(xPos/2, yPos+gHeight/2);
        rotate(radians(270));
        text(yT, 0, 0);
        popMatrix();
    }

    public void displayGraph() {
        textSize(textSize);
        rectMode(CORNER);
        noStroke();
        fill(bg);
        rect(xPos, yPos, gWidth, gHeight);

        PVector graphOrigin = new PVector(xPos, yPos + gHeight);
        

        if (grid) {
            // Optional background grid. Will probably change at some point
            stroke(255, 255, 255, 100);
            for (float i = graphOrigin.y; i >= graphOrigin.y - gHeight; i-=lineDensity) {   // horizontal lines
                line(graphOrigin.x, i, gWidth + graphOrigin.x, i);
            }

            for (float i = graphOrigin.x; i <= graphOrigin.x + gWidth; i+=lineDensity) {     // vertical lines
                line(i, graphOrigin.y - gHeight, i, graphOrigin.y);
            }
        }

        
        // x-axis figures
        if (data_gen) {
            for (int i = 0; i <= xSteps; i++) {
               text(nf((xMin + xMax/xSteps*i), 0, 1), graphOrigin.x + (gWidth/xSteps)*i, graphOrigin.y + textSize*1.5f);
            }
        }

        if (data_set) {
            ArrayList<String> tObj = new ArrayList<String>();
            tObj.addAll(data.keySet());
            textAlign(CENTER);
            for (int i = 0; i < xSteps; i++) {
                if (i%2 == 0) {
                    text(tObj.get(i).substring(0, 5), graphOrigin.x + (gWidth/xSteps)*i + (1*textSize), graphOrigin.y + textSize*3.5f);
                } else {
                    text(tObj.get(i).substring(0, 5), graphOrigin.x + (gWidth/xSteps)*i + (1*textSize), graphOrigin.y + textSize*1.5f);
                }
            }
        }
        
        // y-axis figures
        for (int i = ySteps; i >= 0; i--) {
            text(nf((yMin + yMax/ySteps*i), 0, 1), graphOrigin.x - textSize*2, graphOrigin.y - (gHeight/ySteps)*i);
            if (guideline) {
                println(1);
                stroke(255, 255, 255, 100);
                line(xPos, graphOrigin.y - (gHeight/ySteps)*i, xPos + gWidth, graphOrigin.y - (gHeight/ySteps)*i);
            }
        }
        
        

        ArrayList<Integer> tValues = new ArrayList<Integer>();
        switch (graphType) {
        case "bar":
            tValues.addAll(data.values());
            for (int i = 0; i < xSteps; i++) {
                fill(50);
                rect(graphOrigin.x + (gWidth/xSteps)*(i), graphOrigin.y, width/80, gHeight * ((float)-tValues.get(i) / Collections.max(tValues)));
            }
            break;
        default :
            // defaults to bar type
            tValues.addAll(data.values());
            for (int i = 0; i < xSteps; i++) {
                fill(50);
                rect(graphOrigin.x + (gWidth/xSteps)*(i), graphOrigin.y, width/80, gHeight * ((float)-tValues.get(i) / Collections.max(tValues)));
            }
        break;	
        }

        stroke(255, 0, 0);
        line(graphOrigin.x, graphOrigin.y,  graphOrigin.x + gWidth, graphOrigin.y); // x axis
        line(graphOrigin.x, graphOrigin.y, graphOrigin.x, graphOrigin.y - gHeight);  // y axis
    }
}
public class State {
    ArrayList<Area> areas;

    String name;
    public State(String name, ArrayList<Area> areas) {

        this.name = name;
        this.areas = areas;
    }

    public State(String name) {
        this.name = name;
        this.areas = new ArrayList<Area>();
    }

    public void addArea(Area a) {
        areas.add(a);
    }

    public void addArea(String name, LinkedHashMap<String, Integer> hm, int id) {
        areas.add(new Area(name, hm, id));
    }

    public void addArea(String name, ArrayList<String> dates, ArrayList<Integer> cases, int id) {
        areas.add(new Area(name, dates, cases, id));
    }

    public ArrayList<Area> getAreas() {
        return areas;
    }

    public Area getArea(String name) {
        for (Area a : areas) {
            if (a.getName().equalsIgnoreCase(name)) {
                return a;
            }
        }
        return null;
    }

    public Area getArea(int index) {
        if (index >= 0 && areas != null) {
            try {
                Area a = areas.get(index);
                if (a != null) {
                    return areas.get(index);
                }
            } 
            catch(Exception e) {
            }
        }
        return null;
    }

    public String getName() {
        return name;
    }
}
public class TableData {
    ArrayList<Country> world = new ArrayList<Country>();     // arraylist of countries
    ArrayList<String> tCountries = new ArrayList<String>();  // arraylist of countries
    ArrayList<String> tStates = new ArrayList<String>();     // arraylist of states
    ArrayList<String> tAreas = new ArrayList<String>();      // arraylist of areas
    Table table;

    float objWidth, objHeight, objColor;
    Area place;
    String pppp;
    TableData(Table table) {
        this.table = table;                
        loadTableData();
    }

    TableData(String file) {
        table = loadTable(file, "header");      // load csv data
        loadTableData();
    }

    public void loadTableData() {
        TableRow tempTR = table.getRow(0);                      // get first row
        world.add(new Country(tempTR.getString("country")));    // initialise world with first country



        // add each country in the csv file to the countries arraylist
        for (int i = 0; i < table.getRowCount(); ++i) {
            TableRow tr = table.getRow(i);
            tCountries.add(tr.getString("country"));
        }

        // remove any duplicates
        removeDuplicates(tCountries);

        // add each unique country to the world
        for (String s : tCountries) {
            world.add(new Country(s));
        }


        println("25%...");


        // add all states in the csv file to the states arraylist
        for (int j = 0; j < table.getRowCount(); j++) {
            TableRow tr = table.getRow(j);
            tStates.add(tr.getString("county/state"));
        }

        removeDuplicates(tStates);   // remove any duplicates

        // debug - check if states are unique
        /* println(String.join(", ", states)); */

        // new arraylist which keep track of which states have been added
        ArrayList<String> usedStates = new ArrayList<String>();

        // match each state to its country and add it to that country's state arraylist, avoiding duplicates
        for (int k = 0; k < table.getRowCount(); k++) {
            TableRow tr = table.getRow(k);
            String state = tr.getString("county/state");
            String country = tr.getString("country");
            for (Country co : world) {
                for (String s : tStates) {
                    if (co.getName().equalsIgnoreCase(country) && s.equalsIgnoreCase(state) && !usedStates.contains(s)) {
                        co.addState(new State(s));
                        usedStates.add(s);
                    }
                }
            }
        }


        println("50%...");


        // add all areas in the csv file to the areas arraylist
        for (int i = 0; i < table.getRowCount(); i++) {
            TableRow tr = table.getRow(i);
            tAreas.add(tr.getString("area"));
        }

        removeDuplicates(tAreas);   // remove any duplicates

        // new arraylist which keep track of which areas and IDs have been added
        ArrayList<String> usedAreas = new ArrayList<String>();

        // match each state to its country and add it to that country's state arraylist, avoiding duplicates
        for (int i = 0; i < table.getRowCount(); i++) {
            TableRow tr = table.getRow(i);
            String state = tr.getString("county/state");
            String area = tr.getString("area");
            int id = tr.getInt("geoid");
            for (Country co : world) {
                for (State st : co.states) {
                    for (String a : tAreas) {
                        if (st.getName().equalsIgnoreCase(state) && a.equalsIgnoreCase(area) && !usedAreas.contains(a)) {
                            Area newArea = new Area(a, id);
                            st.addArea(newArea);
                            usedAreas.add(a);
                        }
                    }
                }
            }
        }


        println("75%...");


        // put data (dates and cases) and geoID in correct area
        for (int i = 0; i < table.getRowCount(); i++) {
            TableRow tr = table.getRow(i);
            String area = tr.getString("area");
            int id = tr.getInt("geoid");
            String date = tr.getString("date");
            int cases = tr.getInt("cases");
            String state = tr.getString("county/state");
            for (Country co : world) {
                for (State st : co.states) {
                    for (Area a : st.areas) {
                        if (a.getName().equalsIgnoreCase(area) && st.getName().equalsIgnoreCase(state)) {
                            a.setID(id);
                            a.addInfo(date, cases);
                        }
                    }
                }
            }
        }

        println("100%");

        println("Finished setup.\n");
    }

    public ArrayList<String> getInfo() {
        // Returns all data in the table
        ArrayList<String> info = new ArrayList<String>();
        for (TableRow tr : table.rows()) {
            info.add(
                "\""+ tr.getString("date") + "," + 
                tr.getString("area") +  "," + 
                tr.getString("county/state") + "," + 
                tr.getInt("geoid") +  "," + 
                tr.getInt("cases") +  "," + 
                tr.getString("country") + "\"" 
                );
        }
        return info;
    }

    public ArrayList<String> getInfo(String name, String type) {
        // Returns the rows where the chosen data is mentioned
        ArrayList<String> info = new ArrayList<String>();
        if (name != null) {
            for (TableRow tr : table.rows()) {
                try {
                    if (name.equalsIgnoreCase(tr.getString(type))) {
                        info.add(
                            "\""+ tr.getString("date") + "," + 
                            tr.getString("area") +  "," + 
                            tr.getString("county/state") + "," + 
                            tr.getInt("geoid") +  "," + 
                            tr.getInt("cases") +  "," + 
                            tr.getString("country") + "\"" 
                            );
                    }
                } 
                catch(Exception e) {
                    e.printStackTrace();
                    return null;
                }
            }
            return info;
        }
        return null;
    }
}
    static public void main(String[] passedArgs) {
        String[] appletArgs = new String[] { "--present", "--window-color=#666666", "--stop-color=#cccccc", "loadTableData" };
        if (passedArgs != null) {
          PApplet.main(concat(appletArgs, passedArgs));
        } else {
          PApplet.main(appletArgs);
        }
    }
}
